"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.bundleAsync = exports.runMetroDevServerAsync = void 0;
const config_1 = require("@expo/config");
const ExpoMetroConfig = __importStar(require("@expo/metro-config"));
const cli_server_api_1 = require("@react-native-community/cli-server-api");
const body_parser_1 = __importDefault(require("body-parser"));
const path_1 = __importDefault(require("path"));
const resolve_from_1 = __importDefault(require("resolve-from"));
const semver_1 = __importDefault(require("semver"));
const url_1 = require("url");
const HermesBundler_1 = require("./HermesBundler");
const LogReporter_1 = __importDefault(require("./LogReporter"));
const clientLogsMiddleware_1 = __importDefault(require("./middleware/clientLogsMiddleware"));
const createJsInspectorMiddleware_1 = __importDefault(require("./middleware/createJsInspectorMiddleware"));
async function runMetroDevServerAsync(projectRoot, options) {
    const Metro = importMetroFromProject(projectRoot);
    const reporter = new LogReporter_1.default(options.logger);
    const metroConfig = await ExpoMetroConfig.loadAsync(projectRoot, { reporter, ...options });
    const { middleware, attachToServer } = cli_server_api_1.createDevServerMiddleware({
        port: metroConfig.server.port,
        watchFolders: metroConfig.watchFolders,
    });
    // securityHeadersMiddleware does not support cross-origin requests for remote devtools to get the sourcemap.
    // We replace with the enhanced version.
    replaceMiddlewareWith(middleware, cli_server_api_1.securityHeadersMiddleware, remoteDevtoolsSecurityHeadersMiddleware);
    middleware.use(remoteDevtoolsCorsMiddleware);
    middleware.use(body_parser_1.default.json());
    middleware.use('/logs', clientLogsMiddleware_1.default(options.logger));
    middleware.use('/inspector', createJsInspectorMiddleware_1.default());
    const customEnhanceMiddleware = metroConfig.server.enhanceMiddleware;
    // @ts-ignore can't mutate readonly config
    metroConfig.server.enhanceMiddleware = (metroMiddleware, server) => {
        if (customEnhanceMiddleware) {
            metroMiddleware = customEnhanceMiddleware(metroMiddleware, server);
        }
        return middleware.use(metroMiddleware);
    };
    const serverInstance = await Metro.runServer(metroConfig, { hmrEnabled: true });
    const { messageSocket, eventsSocket } = attachToServer(serverInstance);
    reporter.reportEvent = eventsSocket.reportEvent;
    return {
        server: serverInstance,
        middleware,
        messageSocket,
    };
}
exports.runMetroDevServerAsync = runMetroDevServerAsync;
let nextBuildID = 0;
// TODO: deprecate options.target
async function bundleAsync(projectRoot, expoConfig, options, bundles) {
    const metro = importMetroFromProject(projectRoot);
    const Server = importMetroServerFromProject(projectRoot);
    const reporter = new LogReporter_1.default(options.logger);
    const config = await ExpoMetroConfig.loadAsync(projectRoot, { reporter, ...options });
    const buildID = `bundle_${nextBuildID++}`;
    const metroServer = await metro.runMetro(config, {
        watch: false,
    });
    const buildAsync = async (bundle) => {
        var _a, _b, _c, _d;
        const bundleOptions = {
            ...Server.DEFAULT_BUNDLE_OPTIONS,
            bundleType: 'bundle',
            platform: bundle.platform,
            entryFile: bundle.entryPoint,
            dev: (_a = bundle.dev) !== null && _a !== void 0 ? _a : false,
            minify: (_b = bundle.minify) !== null && _b !== void 0 ? _b : !bundle.dev,
            inlineSourceMap: false,
            sourceMapUrl: bundle.sourceMapUrl,
            createModuleIdFactory: config.serializer.createModuleIdFactory,
            onProgress: (transformedFileCount, totalFileCount) => {
                if (!options.quiet) {
                    reporter.update({
                        buildID,
                        type: 'bundle_transform_progressed',
                        transformedFileCount,
                        totalFileCount,
                    });
                }
            },
        };
        reporter.update({
            buildID,
            type: 'bundle_build_started',
            bundleDetails: {
                bundleType: bundleOptions.bundleType,
                platform: bundle.platform,
                entryFile: bundle.entryPoint,
                dev: (_c = bundle.dev) !== null && _c !== void 0 ? _c : false,
                minify: (_d = bundle.minify) !== null && _d !== void 0 ? _d : false,
            },
        });
        const { code, map } = await metroServer.build(bundleOptions);
        const assets = (await metroServer.getAssets(bundleOptions));
        reporter.update({
            buildID,
            type: 'bundle_build_done',
        });
        return { code, map, assets };
    };
    const maybeAddHermesBundleAsync = async (bundle, bundleOutput) => {
        var _a, _b;
        if (!gteSdkVersion(expoConfig, '42.0.0')) {
            return bundleOutput;
        }
        const isHermesManaged = HermesBundler_1.isEnableHermesManaged(expoConfig, bundle.platform);
        const maybeInconsistentEngine = await HermesBundler_1.maybeInconsistentEngineAsync(projectRoot, bundle.platform, isHermesManaged);
        if (maybeInconsistentEngine) {
            const platform = bundle.platform === 'ios' ? 'iOS' : 'Android';
            const paths = config_1.getConfigFilePaths(projectRoot);
            const configFilePath = (_b = (_a = paths.dynamicConfigPath) !== null && _a !== void 0 ? _a : paths.staticConfigPath) !== null && _b !== void 0 ? _b : 'app.json';
            const configFileName = path_1.default.basename(configFilePath);
            throw new Error(`JavaScript engine configuration is inconsistent between ${configFileName} and ${platform} native project.\n` +
                `In ${configFileName}: Hermes is ${isHermesManaged ? 'enabled' : 'not enabled'}\n` +
                `In ${platform} native project: Hermes is ${isHermesManaged ? 'not enabled' : 'enabled'}\n` +
                `Please check the following files for inconsistencies:\n` +
                `  - ${configFilePath}\n` +
                `  - ${path_1.default.join(projectRoot, 'android', 'gradle.properties')}\n` +
                `  - ${path_1.default.join(projectRoot, 'android', 'app', 'build.gradle')}\n` +
                'Learn more: https://expo.fyi/hermes-android-config');
        }
        if (isHermesManaged) {
            options.logger.info({ tag: 'expo' }, `ðŸ’¿ Building Hermes bytecode for the bundle - platform[${bundle.platform}]`);
            const hermesBundleOutput = await HermesBundler_1.buildHermesBundleAsync(projectRoot, bundleOutput.code, bundleOutput.map, bundle.minify);
            bundleOutput.hermesBytecodeBundle = hermesBundleOutput.hbc;
            bundleOutput.hermesSourcemap = hermesBundleOutput.sourcemap;
        }
        return bundleOutput;
    };
    try {
        return await Promise.all(bundles.map(async (bundle) => {
            const bundleOutput = await buildAsync(bundle);
            return maybeAddHermesBundleAsync(bundle, bundleOutput);
        }));
    }
    finally {
        metroServer.end();
    }
}
exports.bundleAsync = bundleAsync;
function importMetroFromProject(projectRoot) {
    const resolvedPath = resolve_from_1.default.silent(projectRoot, 'metro');
    if (!resolvedPath) {
        throw new Error('Missing package "metro" in the project at ' +
            projectRoot +
            '. ' +
            'This usually means `react-native` is not installed. ' +
            'Please verify that dependencies in package.json include "react-native" ' +
            'and run `yarn` or `npm install`.');
    }
    return require(resolvedPath);
}
function importMetroServerFromProject(projectRoot) {
    const resolvedPath = resolve_from_1.default.silent(projectRoot, 'metro/src/Server');
    if (!resolvedPath) {
        throw new Error('Missing module "metro/src/Server" in the project. ' +
            'This usually means React Native is not installed. ' +
            'Please verify that dependencies in package.json include "react-native" ' +
            'and run `yarn` or `npm install`.');
    }
    return require(resolvedPath);
}
function replaceMiddlewareWith(app, sourceMiddleware, targetMiddleware) {
    const item = app.stack.find(middleware => middleware.handle === sourceMiddleware);
    if (item) {
        item.handle = targetMiddleware;
    }
}
// Like securityHeadersMiddleware but further allow cross-origin requests
// from https://chrome-devtools-frontend.appspot.com/
function remoteDevtoolsSecurityHeadersMiddleware(req, res, next) {
    // Block any cross origin request.
    if (typeof req.headers.origin === 'string' &&
        !req.headers.origin.match(/^https?:\/\/localhost:/) &&
        !req.headers.origin.match(/^https:\/\/chrome-devtools-frontend\.appspot\.com/)) {
        next(new Error(`Unauthorized request from ${req.headers.origin}. ` +
            'This may happen because of a conflicting browser extension to intercept HTTP requests. ' +
            'Please try again without browser extensions or using incognito mode.'));
        return;
    }
    // Block MIME-type sniffing.
    res.setHeader('X-Content-Type-Options', 'nosniff');
    next();
}
// Middleware that accepts multiple Access-Control-Allow-Origin for processing *.map.
// This is a hook middleware before metro processing *.map,
// which originally allow only devtools://devtools
function remoteDevtoolsCorsMiddleware(req, res, next) {
    var _a;
    if (req.url) {
        const url = url_1.parse(req.url);
        const origin = req.headers.origin;
        const isValidOrigin = origin &&
            ['devtools://devtools', 'https://chrome-devtools-frontend.appspot.com'].includes(origin);
        if (((_a = url.pathname) === null || _a === void 0 ? void 0 : _a.endsWith('.map')) && origin && isValidOrigin) {
            res.setHeader('Access-Control-Allow-Origin', origin);
            // Prevent metro overwrite Access-Control-Allow-Origin header
            const setHeader = res.setHeader.bind(res);
            res.setHeader = (key, ...args) => {
                if (key === 'Access-Control-Allow-Origin') {
                    return;
                }
                setHeader(key, ...args);
            };
        }
    }
    next();
}
// Cloned from xdl/src/Versions.ts, we cannot use that because of circular dependency
function gteSdkVersion(expJson, sdkVersion) {
    if (!expJson.sdkVersion) {
        return false;
    }
    if (expJson.sdkVersion === 'UNVERSIONED') {
        return true;
    }
    try {
        return semver_1.default.gte(expJson.sdkVersion, sdkVersion);
    }
    catch (e) {
        throw new Error(`${expJson.sdkVersion} is not a valid version. Must be in the form of x.y.z`);
    }
}
//# sourceMappingURL=MetroDevServer.js.map